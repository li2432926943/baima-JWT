# p2：首页顶部(前端设计)(盒子模型)

前端的页面设计就像盒子。比如一个页面是一个大盒子，然后上下分两个部分也是盒子，每一个部分里面的内容也算是盒子。所以记住前端设计的盒子模型。设计样式的话，给盒子里面的每一个部分的小盒子去写一个class设置名字，然后在下面写css就好了





# p4：导航栏设计，图标，滚动条







# p5：顶部搜索栏，按分类搜搜(优化性能)，用户信息弹出框，个人设置退出登陆等







# p6：根据不同侧边栏切换main，所以main要写一个二级路由

![image-20250518171610799](C:\Users\10156\AppData\Roaming\Typora\typora-user-images\image-20250518171610799.png)





# p7：定义card子组件，defineProps定义属性。在父组件usersetting里面复用子组件

写法与使用：props：属性

```java
defineProps({
  icon: Object,
  title: String,
  desc: String
})
```

1. `defineProps` 是 Vue 3 的 `<script setup>` 语法糖中的一个编译器宏（Compiler Macro），用于声明组件的 props。

2. 这段代码定义了三个 prop：
   - `icon`: 类型为 Object（对象）
   - `title`: 类型为 String（字符串）
   - `desc`: 类型为 String（字符串）

3. 主要作用：
   - 允许父组件向这个 Card 组件传递数据
   - 定义了允许接收的数据类型，提供类型检查
   - 使得这些属性可以在模板中使用

4. 使用示例：
```vue
<Card 
  :icon="{ ... }"
  title="标题"
  desc="描述文本"
/>
```

在你的组件中，这些 props 被用于：
- `icon` 用于显示卡片的图标
- `title` 用于显示卡片的标题
- `desc` 用于显示卡片的描述文本

这是 Vue 3 组件通信的基础方式之一，通过 props 可以实现父组件向子组件传递数据。



## 这些属性props的数据从哪里来？从调用它的父组件传递过来

在这个组件中，数据的接收体现在几个地方：

1. 在模板中的接收使用：
```vue
<template>
  <!-- v-if="title" 使用了 title 属性 -->
  <div class="card-header" v-if="title">
    <div>
      <!-- :is="icon" 使用了 icon 属性 -->
      <el-icon>
        <component :is="icon"/>
      </el-icon>
      <!-- {{title}} 使用了 title 属性 -->
      {{title}}
    </div>
    <!-- {{ desc }} 使用了 desc 属性 -->
    <div>{{ desc }}</div>
  </div>
</template>
```

具体解释：
1. `v-if="title"`: 判断是否有 title，有才显示 card-header
2. `:is="icon"`: 动态渲染图标组件
3. `{{title}}`: 显示标题文本
4. `{{ desc }}`: 显示描述文本

这些都是在使用父组件传递过来的属性。当父组件像这样使用 Card 组件时：
```vue
<Card 
  :icon="Document"
  title="我的标题"
  desc="描述文字"
/>
```
这些值就会被渲染到对应的位置。

所以说，接收是在整个模板中通过各种方式使用这些 props 值来实现的。Vue 会自动处理这个数据传递和绑定的过程。

## < slot/ >定义插槽

### 就是父组件调用子组件的话，在调用子组件里面写的内容就会全部放到插槽这个位置

`<slot/>` 是 Vue 中一个非常重要的功能，用于内容分发，实现组件的可扩展性。让我详细解释：

1. 基本概念：
- slot 是插槽的意思，它允许父组件向子组件传递 HTML 内容
- 可以理解为是组件中的一个"占位符"，父组件可以在这个位置插入任何内容

2. 基本用法：
```vue
<!-- 子组件(Card.vue) -->
<template>
  <div class="card">
    <!-- 其他内容 -->
    <slot/>  <!-- 插槽位置 -->
  </div>
</template>

<!-- 父组件中使用 -->
<Card>
  <!-- 这里的内容会被放到子组件的 slot 位置 -->
  <div>这是插入的内容</div>
  <p>可以插入任何HTML元素</p>
</Card>
```

3. 实际应用场景：
```vue
<!-- 父组件中使用你的Card组件 -->
<Card 
  :icon="Document" 
  title="标题"
  desc="描述"
>
  <!-- 这些内容会被放到 slot 位置 -->
  <div class="card-content">
    <p>这是卡片的主要内容</p>
    <el-button>点击按钮</el-button>
  </div>
</Card>
```

### 等价于

是的，你理解得完全正确！让我用一个具体例子来说明：

假设你在父组件中这样使用 Card 组件：

```vue
<!-- 父组件中 -->
<Card 
  :icon="Document" 
  title="我的卡片" 
  desc="这是描述"
>
  <!-- 这里的所有内容都会被放到子组件的 <slot/> 位置 -->
  <div class="content">
    <h3>这是内容标题</h3>
    <p>这是一段文字描述</p>
    <el-button>点击按钮</el-button>
  </div>
</Card>
```

最终渲染效果相当于：

```vue
<div class="card">
  <!-- card-header 部分保持不变 -->
  <div class="card-header">
    <div>
      <el-icon><component :is="Document"/></el-icon>
      我的卡片
    </div>
    <div>这是描述</div>
  </div>
  
  <!-- <slot/> 位置被替换为父组件传入的内容 -->
  <div class="content">
    <h3>这是内容标题</h3>
    <p>这是一段文字描述</p>
    <el-button>点击按钮</el-button>
  </div>
</div>
```

这就是为什么 slot 这么强大：
- 可以在保持卡片基础样式的同时自定义内容
- 一个卡片组件可以适应不同的内容需求
- 提高了组件的复用性和灵活性

5. 在你的 Card 组件中的作用：
- 允许使用者自定义卡片的主体内容
- 保持了组件的灵活性和可复用性
- 可以在保持相同卡片样式的同时，放入不同的内容

这样的设计让你的 Card 组件变得更加灵活，可以适应各种不同的使用场景。父组件可以在保持卡片基本样式和结构的同时，自由定制卡片的内容部分。



# p8:设置界面后端

1：根据需求设计字段设计表。

2：映射实体类

3：创建mapper接口，mapper要拿到实体类

4：创建service接口(方便调用)

5：创建serviceimpl实现类，拿到mapper和实体类还有iservice

## 我们的需求

### 1：打开用户信息页面的时候，我们要从数据库中查出数据，显示到界面

1：数据库db_account_details一开始是没数据的，要么我们在用户注册的时候，同时向两张表里面丢数据。

2：要么动态更新（没有的话就保存，有的话就更新。）（减轻第一种数据库压力）



前端提交过来的数据，我们要封装成vo对象DetailsSaveVO   （VO也可以作为参数传入方法种）

![image-20250518225643452](https://s2.loli.net/2025/05/18/qH879zhPVQu15Co.png)

![image-20250518225435512](https://s2.loli.net/2025/05/18/CDEpfGbBJZxkjP2.png)

### 2：保存用户信息，向数据库去保存

### 代码讲解

```java
    @Override
    @Transactional
    public synchronized boolean saveAccountDetails(int id, DetailsSaveVO vo) {
        Account account = service.findAccountByNameOrEmail(vo.getUsername());
        if(account == null || account.getId() == id) {
            service.update()
                    .eq("id", id)
                    .set("username", vo.getUsername())
                    .update();
            this.saveOrUpdate(new AccountDetails(
                    id, vo.getGender(), vo.getPhone(),
                    vo.getQq(), vo.getWx(), vo.getDesc()
            ));
            return true;
        }
        return false;
    }
```

我用大白话给你解释这段代码是干什么的：

这是一个保存账号详细信息的方法，主要做了以下几件事：

1. 首先这个方法加了"锁"（synchronized），保证同一时间只能有一个人调用，避免多人同时操作出问题。

2. 它先根据用户名或邮箱查找是否已经存在这个账号（account）。

3. 如果没找到这个账号（account == null），或者找到的账号就是当前要修改的账号（account.getId() == id），就执行更新操作：
   - 更新账号的基本信息（主要是用户名）
   - 然后保存或更新账号的详细信息（包括性别、电话、QQ、微信、个人描述等）

4. 如果发现这个用户名已经被其他账号使用了（既不是空也不是当前账号），就直接返回false，表示更新失败。

简单说就是：检查用户名是否被占用，没被占用就更新账号信息，被占用了就不让改。

补充说明：
- @Transactional 表示这些操作是一个整体，要么全部成功，要么全部失败回滚
- @Override 表示这是重写父类的方法
- 方法返回true表示更新成功，false表示失败（用户名冲突）



# 为什么要写常量类，如何理解@RequestAttribute(Const.ATTR_USER_ID) int id

## 从请求的属性里面读取Const.ATTR_USER_ID=userid这个键对应的值，然后赋值int id中

## Const.ATTR_USER_ID这样写就是为了方便全局替换

## Attribute:属性

```java
@GetMapping("/info")
    public RestBean<AccountVO> info(@RequestAttribute(Const.ATTR_USER_ID) int id){
        Account account = service.findAccountById(id);
        return RestBean.success(account.asViewObject(AccountVO.class));
    }
```

![image-20250519170305707](https://s2.loli.net/2025/05/19/c9g4uQOrPRWwv65.png)

是的，**`@RequestAttribute(Const.ATTR_USER_ID) int id` 的作用就是：**  
1. **从当前请求的属性（Request Attributes）中**，找到键为 `Const.ATTR_USER_ID`（比如 `"userId"`）对应的值。  
2. **自动将该值转换为 `int` 类型**，并赋值给方法参数 `id`。  

---

### **具体步骤（大白话版）**
1. **拦截器提前存值**  
   在请求到达 Controller 之前，拦截器已经做了类似这样的事情：
   ```java
   // 拦截器代码示例
   request.setAttribute("userId", 123); // 把用户ID存到请求属性中
   ```
   - 这时，请求内部会有一个类似 `Map` 的结构：`{"userId": 123}`。

2. **Controller 方法读取值**  
   当请求进入你的方法时：
   ```java
   public RestBean<AccountVO> info(@RequestAttribute(Const.ATTR_USER_ID) int id) {
       // Spring 会做以下事情：
       // 1. 从请求属性中找到键 "userId" 对应的值（123）
       // 2. 把值 123 转换成 int 类型
       // 3. 赋值给参数 id
       System.out.println(id); // 输出：123
   }
   ```
   - 最终 `id` 的值就是拦截器预先存入的 `123`（动态的，每个用户不同）。

---

### **关键细节**
1. **类型自动转换**  
   - 如果请求属性中的值是 `String "123"`，Spring 会自动转换成 `int 123`。  
   - 如果无法转换（比如值是 `"abc"`），会抛出异常。

2. **必须存在该属性**  
   - 如果拦截器没有设置 `"userId"` 属性，Spring 会直接报错（`MissingRequestAttributeException`）。  
   - 确保拦截器一定在 Controller 之前运行（通常通过配置顺序或注解优先级保证）。

3. **常量只是键名**  
   - `Const.ATTR_USER_ID` 是固定的键名（如 `"userId"`），但对应的值（`123` 或 `456`）是动态的、随请求变化的。

---



你的问题很好，我来用更通俗的方式解释这个设计逻辑，包括 **为什么用常量 `Const.ATTR_USER_ID`** 和 **为什么能传入不同的用户 ID**。

---

### **1. 常量的作用：统一管理键名**
`Const.ATTR_USER_ID` 是一个常量（比如定义成 `public static final String ATTR_USER_ID = "userId"`），它的核心作用是：

- **避免硬编码**：如果代码里到处直接写 `"userId"`，万一要改名（比如改成 `"user_id"`），需要全局搜索替换，容易出错。用常量只需改一处。
- **提高可读性**：`Const.ATTR_USER_ID` 比直接写 `"userId"` 更明确，一看就知道是“用户ID的属性键”。

#### **类比**
- 就像你家的电表号（比如 `A12345`），如果每次交电费都直接写这个号码，容易输错。不如定义一个常量 `ELECTRIC_METER_ID = "A12345"`，用的时候直接引用。

---

### **2. 为什么能传入不同的用户 ID？**
虽然 `Const.ATTR_USER_ID` 是常量（键名不变），但 **键对应的值（用户ID）是动态的**，理解两点：

#### **(1) 请求属性（Request Attribute）的本质**
- 可以把它想象成一个 **Map（键值对集合）**，比如：
  ```java
  Map<String, Object> requestAttributes = {
      "userId": 123,     // 当前请求的用户ID是123
      "requestTime": "2023-01-01"
  };
  ```
  - **键（Key）**：`Const.ATTR_USER_ID`（固定常量，如 `"userId"`）。
  - **值（Value）**：动态的（比如用户A的ID是 `123`，用户B的ID是 `456`）。

#### **(2) 拦截器的行为**
- 在用户请求到达 Controller 前，拦截器会做以下事情：
  1. 解析 Token/Cookie/Session，拿到当前用户的真实 ID（比如 `123`）。
  2. **把这个 ID 存入请求属性**，键是常量 `Const.ATTR_USER_ID`，值是动态的 `123`：
     ```java
     request.setAttribute(Const.ATTR_USER_ID, 123); // 键固定，值变化
     ```
- 这样 Controller 方法每次读取 `@RequestAttribute(Const.ATTR_USER_ID)` 时：
  - **键永远是 `Const.ATTR_USER_ID`**（常量保证一致性）。
  - **值根据当前请求的用户变化**（动态性）。

---





## pinia全局状态管理(在局部修改，全局都会修改)

在 Pinia 中，状态（state）是响应式的，并且是共享的。我来详细解释：

1. 当你在组件中使用 store 时：
```javascript
import { useStore } from '@/store'

// 在组件中
const store = useStore()

// 修改状态
store.user.username = '新用户名'
```

这个修改会：
- 直接改变中央存储的状态
- 所有使用这个状态的组件都会自动更新
- 不是复制，而是引用同一个状态

2. 正确的修改方式示例：
```javascript
// 组件A
const store = useStore()
store.user.username = '张三'  // 修改用户名

// 组件B
const store = useStore()
console.log(store.user.username)  // 输出：'张三'
```

3. 如果你想要复制而不影响原状态：
```javascript
const store = useStore()
// 创建副本
const userCopy = { ...store.user }
// 修改副本
userCopy.username = '新名字'
// 这不会影响原状态
```

所以：
- store 中的状态是全局共享的
- 一处修改，处处生效
- 这就是状态管理的核心作用：保持数据的一致性

如果需要局部独立的状态，应该使用组件的 `data()` 或 `ref()`/`reactive()`。





## 代码讲解

```java
<el-form :model="baseForm" :rules="rules" ref="baseFormRef" label-position="top"

style="margin: 0 10px 10px 10px">

<el-form-item label="用户名" prop="username">

<el-input v-model="baseForm.username" maxlength="10"/>

</el-form-item>
```

讲解一下ref="baseFormRef"和prop="username"是干什么，大白话

让我用大白话解释这两个属性：

1. `ref="baseFormRef"`：
- 相当于给这个表单起了个名字叫"baseFormRef"
- 这样在代码中就能直接找到这个表单，对它进行操作
- 比如验证表单内容是否正确、重置表单等
- 就像给小孩起名字一样，要找他的时候直接喊名字就行

在你的代码中的使用例子：
```javascript
// 通过 baseFormRef 找到表单，然后验证表单内容
baseFormRef.value.validate(isValid => {
    if (isValid) {
        // 表单验证通过，继续处理...
    }
})
```

2. `prop="username"`：
- 告诉表单这个输入框对应的是验证规则中的 "username" 规则
- 就像是给这个输入框贴了个标签，说"我要按username的规则来验证"
- 对应你代码中定义的验证规则：
```javascript
const rules = {
    username: [  // 这里的 username 就对应 prop="username"
        {validator: validateUsername, trigger: ['blur', 'change']},
        {min: 2, max: 10, message: '用户名的长度必须在2-10个字符之间', trigger: ['blur', 'change']},
    ]
}
```

简单来说：
- ref 是为了方便找到这个表单
- prop 是为了知道用哪个规则来验证这个输入框